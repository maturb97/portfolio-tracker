<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Elite Portfolio Analytics Platform</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body class="bg-gray-50 min-h-screen">
    <div class="container mx-auto px-4 py-6">
        
        <!-- Header -->
        <header class="mb-8">
            <h1 class="text-3xl font-bold text-gray-800 mb-2">üìä Elite Portfolio Analytics</h1>
            <p class="text-gray-600">Professional portfolio tracker with advanced analytics</p>
        </header>

        <!-- Portfolio Overview Cards -->
        <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 mb-8">
            
            <div class="bg-white rounded-lg shadow p-6">
                <h3 class="text-sm font-medium text-gray-500 mb-2">Total Portfolio Value</h3>
                <div class="text-3xl font-bold text-blue-600" id="total-value">Loading...</div>
                <div class="text-sm text-gray-600 mt-1" id="total-change">Calculating...</div>
            </div>

            <div class="bg-white rounded-lg shadow p-6">
                <h3 class="text-sm font-medium text-gray-500 mb-2">Unrealized P&L</h3>
                <div class="text-3xl font-bold" id="unrealized-pl">Loading...</div>
                <div class="text-sm text-gray-600 mt-1" id="unrealized-percent">0.00%</div>
            </div>

            <div class="bg-white rounded-lg shadow p-6">
                <h3 class="text-sm font-medium text-gray-500 mb-2">Realized P&L</h3>
                <div class="text-3xl font-bold" id="realized-pl">Loading...</div>
                <div class="text-sm text-gray-600 mt-1">YTD Performance</div>
            </div>

            <div class="bg-white rounded-lg shadow p-6">
                <h3 class="text-sm font-medium text-gray-500 mb-2">Total Dividends</h3>
                <div class="text-3xl font-bold text-green-600" id="total-dividends">Loading...</div>
                <div class="text-sm text-gray-600 mt-1" id="dividend-yield">Yield: 0.00%</div>
            </div>

        </div>

        <!-- Holdings Table -->
        <div class="bg-white rounded-lg shadow overflow-hidden mb-8">
            <div class="px-6 py-4 border-b border-gray-200">
                <h3 class="text-lg font-semibold">Current Holdings</h3>
            </div>
            <div class="overflow-x-auto">
                <table class="w-full">
                    <thead class="bg-gray-50">
                        <tr>
                            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">Symbol</th>
                            <th class="px-6 py-3 text-right text-xs font-medium text-gray-500 uppercase">Units</th>
                            <th class="px-6 py-3 text-right text-xs font-medium text-gray-500 uppercase">Current Price</th>
                            <th class="px-6 py-3 text-right text-xs font-medium text-gray-500 uppercase">Market Value</th>
                            <th class="px-6 py-3 text-right text-xs font-medium text-gray-500 uppercase">Cost Basis</th>
                            <th class="px-6 py-3 text-right text-xs font-medium text-gray-500 uppercase">P&L</th>
                            <th class="px-6 py-3 text-right text-xs font-medium text-gray-500 uppercase">P&L %</th>
                        </tr>
                    </thead>
                    <tbody id="holdings-body" class="bg-white divide-y divide-gray-200">
                        <tr>
                            <td colspan="7" class="px-6 py-4 text-center text-gray-500">Loading portfolio data...</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <!-- Charts -->
        <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-8">
            <div class="bg-white rounded-lg shadow p-6">
                <h3 class="text-lg font-semibold mb-4">Portfolio Value Over Time</h3>
                <canvas id="value-chart" height="300"></canvas>
            </div>
            <div class="bg-white rounded-lg shadow p-6">
                <h3 class="text-lg font-semibold mb-4">Market Allocation</h3>
                <canvas id="allocation-chart" height="300"></canvas>
            </div>
        </div>

        <!-- Status -->
        <div class="bg-blue-50 border border-blue-200 rounded-lg p-4">
            <div class="flex items-center">
                <div class="text-blue-800">
                    <span id="status">üöÄ Loading your portfolio data...</span>
                </div>
            </div>
        </div>

    </div>

    <script>
        // Configuration
        const CONFIG = {
            GOOGLE_SHEETS_API_KEY: 'AIzaSyCOQSG4yD4SzdrQDJH2oVJGazduyzgwq04',
            SHEET_ID: '10NuWmVJXpI1xeiiFXY5jtGHQ_SNcRbQUGS2kRyGmAKg',
            SHEET_RANGE: 'Sheet1!A:I'
        };

        let portfolio = {
            holdings: new Map(),
            totalValue: 0,
            totalCost: 0,
            unrealizedPL: 0,
            realizedPL: 0,
            totalDividends: 0
        };

        let exchangeRates = {
            'USD/PLN': 4.0 // Default fallback rate
        };

        // Initialize app
        async function init() {
            try {
                document.getElementById('status').textContent = 'üìä Loading transactions from Google Sheets...';
                
                const transactions = await fetchTransactions();
                console.log('Loaded transactions:', transactions);
                
                document.getElementById('status').textContent = 'üí∞ Processing portfolio data...';
                
                processTransactions(transactions);
                
                document.getElementById('status').textContent = 'üí± Fetching exchange rates...';
                
                await updateExchangeRates();
                
                document.getElementById('status').textContent = 'üìà Fetching current prices...';
                
                await updatePrices();
                
                document.getElementById('status').textContent = 'üé® Updating display...';
                
                updateDisplay();
                
                document.getElementById('status').textContent = '‚úÖ Portfolio loaded successfully!';
                
            } catch (error) {
                console.error('Error initializing app:', error);
                document.getElementById('status').textContent = '‚ùå Error loading portfolio. Using sample data.';
                loadSampleData();
                updateDisplay();
            }
        }

        async function fetchTransactions() {
            const url = `https://sheets.googleapis.com/v4/spreadsheets/${CONFIG.SHEET_ID}/values/${CONFIG.SHEET_RANGE}?key=${CONFIG.GOOGLE_SHEETS_API_KEY}`;
            
            const response = await fetch(url);
            if (!response.ok) {
                throw new Error(`Google Sheets API error: ${response.status}`);
            }
            
            const data = await response.json();
            
            if (!data.values || data.values.length < 2) {
                throw new Error('No data found');
            }
            
            // Parse transactions (skip header)
            return data.values.slice(1).map(row => ({
                date: row[0],
                type: row[1],
                market: row[2],
                symbol: row[3] || 'Unknown',
                units: parseFloat(row[4]) || 0,
                price: parseFloat(row[5]) || 0,
                fees: parseFloat(row[6]) || 0,
                split: parseFloat(row[7]) || 1.0,
                currency: row[8] || 'USD'
            })).filter(tx => tx.date && tx.type);
        }

        function processTransactions(transactions) {
            portfolio.holdings.clear();
            
            transactions.forEach(tx => {
                if (!portfolio.holdings.has(tx.symbol)) {
                    portfolio.holdings.set(tx.symbol, {
                        symbol: tx.symbol,
                        market: tx.market,
                        currency: tx.currency,
                        units: 0,
                        totalCost: 0,
                        dividends: 0,
                        realizedPL: 0,
                        currentPrice: 0,
                        marketValue: 0
                    });
                }
                
                const holding = portfolio.holdings.get(tx.symbol);
                
                // Convert transaction values to PLN if needed
                let txPricePLN = tx.price;
                let txFeesPLN = tx.fees;
                
                if (tx.currency === 'USD') {
                    txPricePLN = tx.price * exchangeRates['USD/PLN'];
                    txFeesPLN = tx.fees * exchangeRates['USD/PLN'];
                }
                
                switch (tx.type.toLowerCase()) {
                    case 'buy':
                        // Add to FIFO queue for proper cost basis tracking
                        if (!holding.fifoQueue) holding.fifoQueue = [];
                        holding.fifoQueue.push({
                            units: tx.units,
                            costPerUnit: txPricePLN + (txFeesPLN / tx.units)
                        });
                        holding.units += tx.units;
                        holding.totalCost += (tx.units * txPricePLN) + txFeesPLN;
                        break;
                    case 'sell':
                        // FIFO calculation (First In, First Out)
                        if (!holding.fifoQueue) holding.fifoQueue = [];
                        let unitsToSell = tx.units;
                        let sellCost = 0;
                        
                        // Sell from oldest purchases first (FIFO)
                        while (unitsToSell > 0 && holding.fifoQueue.length > 0) {
                            const batch = holding.fifoQueue[0];
                            const unitsFromBatch = Math.min(unitsToSell, batch.units);
                            sellCost += unitsFromBatch * batch.costPerUnit;
                            
                            batch.units -= unitsFromBatch;
                            unitsToSell -= unitsFromBatch;
                            
                            // Remove empty batches
                            if (batch.units === 0) {
                                holding.fifoQueue.shift();
                            }
                        }
                        
                        const sellValue = (tx.units * txPricePLN) - txFeesPLN;
                        holding.realizedPL += sellValue - sellCost;
                        holding.units -= tx.units;
                        holding.totalCost -= sellCost;
                        break;
                    case 'div':
                        holding.dividends += (tx.units * txPricePLN) - txFeesPLN;
                        break;
                    case 'split':
                        holding.units *= tx.split;
                        holding.totalCost = holding.totalCost; // Cost basis remains same
                        break;
                }
            });
            
            // Remove holdings with 0 units
            portfolio.holdings.forEach((holding, symbol) => {
                if (holding.units <= 0) {
                    portfolio.holdings.delete(symbol);
                }
            });
        }

        async function updatePrices() {
            const promises = Array.from(portfolio.holdings.keys()).map(async symbol => {
                try {
                    const priceUSD = await fetchPrice(symbol);
                    const holding = portfolio.holdings.get(symbol);
                    
                    // Convert USD to PLN if needed
                    let priceInPLN = priceUSD;
                    if (holding.currency === 'USD') {
                        priceInPLN = priceUSD * exchangeRates['USD/PLN'];
                    }
                    
                    holding.currentPrice = priceInPLN;
                    holding.marketValue = holding.units * priceInPLN;
                    holding.priceError = null; // Clear any previous errors
                    
                    console.log(`${symbol}: $${priceUSD} ‚Üí z≈Ç${priceInPLN.toFixed(2)}`);
                    
                } catch (error) {
                    console.error(`‚ùå Failed to fetch price for ${symbol}:`, error.message);
                    const holding = portfolio.holdings.get(symbol);
                    if (holding) {
                        holding.priceError = error.message;
                        holding.currentPrice = 0;
                        holding.marketValue = 0;
                    }
                }
            });
            
            await Promise.allSettled(promises);
            
            // Calculate totals
            portfolio.totalValue = 0;
            portfolio.totalCost = 0;
            portfolio.unrealizedPL = 0;
            portfolio.realizedPL = 0;
            portfolio.totalDividends = 0;
            
            portfolio.holdings.forEach(holding => {
                portfolio.totalValue += holding.marketValue;
                portfolio.totalCost += holding.totalCost;
                portfolio.unrealizedPL += holding.marketValue - holding.totalCost;
                portfolio.realizedPL += holding.realizedPL;
                portfolio.totalDividends += holding.dividends;
            });
        }

        async function fetchPrice(symbol) {
            try {
                const holding = portfolio.holdings.get(symbol);
                if (!holding) return 100;

                let price = null;

                // Determine market and fetch appropriate price
                switch (holding.market) {
                    case 'CRYPTO':
                        price = await fetchCryptoPrice(symbol);
                        break;
                    case 'US':
                    case 'PL':
                        price = await fetchStockPrice(symbol);
                        break;
                    case 'PHYSICAL':
                        price = await fetchCommodityPrice(symbol);
                        break;
                    default:
                        price = await fetchStockPrice(symbol);
                }

                return price || 100; // Fallback price
            } catch (error) {
                console.error(`Error fetching price for ${symbol}:`, error);
                return 100; // Fallback price
            }
        }

        async function fetchStockPrice(symbol) {
            try {
                // Try multiple APIs for better reliability
                
                // Try Alpha Vantage free API (alternative to Yahoo)
                const alphaVantageKey = 'demo'; // You'll need to get a free API key
                const alphaUrl = `https://www.alphavantage.co/query?function=GLOBAL_QUOTE&symbol=${symbol}&apikey=${alphaVantageKey}`;
                
                let price = null;
                
                // Try Yahoo Finance API first
                try {
                    const yahooUrl = `https://query1.finance.yahoo.com/v8/finance/chart/${symbol}`;
                    const response = await fetch(yahooUrl);
                    
                    if (response.ok) {
                        const data = await response.json();
                        price = data.chart?.result?.[0]?.meta?.regularMarketPrice;
                        if (price) {
                            console.log(`‚úÖ Fetched ${symbol} from Yahoo: $${price}`);
                            return price;
                        }
                    }
                } catch (error) {
                    console.warn(`Yahoo Finance failed for ${symbol}:`, error.message);
                }
                
                // Try financialmodelingprep API (no API key needed for some endpoints)
                try {
                    const fmpUrl = `https://financialmodelingprep.com/api/v3/quote-short/${symbol}`;
                    const response = await fetch(fmpUrl);
                    
                    if (response.ok) {
                        const data = await response.json();
                        price = data[0]?.price;
                        if (price) {
                            console.log(`‚úÖ Fetched ${symbol} from FMP: $${price}`);
                            return price;
                        }
                    }
                } catch (error) {
                    console.warn(`FMP failed for ${symbol}:`, error.message);
                }
                
                // For Polish stocks, try different approach
                if (symbol === 'CDR' || symbol === 'ACP' || symbol === 'PLI') {
                    // Try Polish stock exchange API or hardcoded current prices
                    const polishPrices = {
                        'CDR': 140.00,  // PLN - current CD Projekt price
                        'ACP': 165.00,  // PLN - current Asseco price  
                        'PLI': 13.4     // PLN - current PLI price (NewConnect)
                    };
                    price = polishPrices[symbol];
                    if (price) {
                        console.log(`‚úÖ Using Polish stock price for ${symbol}: z≈Ç${price}`);
                        return price;
                    }
                }
                
                // Updated fallback prices (more recent)
                const fallbackPrices = {
                    'AAPL': 227.52,
                    'MSFT': 441.06,
                    'GOOGL': 185.51,
                    'TSLA': 263.26,
                    'AMZN': 199.50,
                    'META': 565.32,
                    'NVDA': 138.07,
                    'MO': 51.40,
                    'BKH': 57.81,
                    'ENB': 42.18,
                    'NEM': 38.92,
                    'GOLD': 22.67,
                    'VALE': 10.08,
                    'CTRA': 24.85,
                    'MMM': 133.48,
                    'VICI': 30.79,
                    'PEP': 156.71,
                    'BATS': 34.50
                };
                
                console.log(`‚ö†Ô∏è Using fallback price for ${symbol}`);
                return fallbackPrices[symbol] || 100;
                
            } catch (error) {
                console.error(`Error fetching stock price for ${symbol}:`, error);
                return 100;
            }
        }

        async function fetchCryptoPrice(symbol) {
            try {
                const cryptoIds = {
                    'Bitcoin': 'bitcoin',
                    'BTC': 'bitcoin',
                    'Ethereum': 'ethereum',
                    'ETH': 'ethereum'
                };
                
                const coinId = cryptoIds[symbol] || symbol.toLowerCase();
                const url = `https://api.coingecko.com/api/v3/simple/price?ids=${coinId}&vs_currencies=usd`;
                
                const response = await fetch(url);
                
                if (response.ok) {
                    const data = await response.json();
                    const price = data[coinId]?.usd;
                    if (price) {
                        console.log(`Fetched ${symbol}: $${price}`);
                        return price;
                    }
                }
                
                // Fallback prices
                const fallbackPrices = {
                    'Bitcoin': 67250.00,
                    'BTC': 67250.00,
                    'Ethereum': 3750.00,
                    'ETH': 3750.00
                };
                
                console.log(`Using fallback price for ${symbol}`);
                return fallbackPrices[symbol] || 100;
                
            } catch (error) {
                console.error(`Error fetching crypto price for ${symbol}:`, error);
                return 100;
            }
        }

        async function fetchCommodityPrice(symbol) {
            try {
                if (symbol.toLowerCase().includes('silver')) {
                    const url = 'https://api.coingecko.com/api/v3/simple/price?ids=silver&vs_currencies=usd';
                    const response = await fetch(url);
                    
                    if (response.ok) {
                        const data = await response.json();
                        const price = data.silver?.usd;
                        if (price) {
                            console.log(`Fetched ${symbol}: $${price}`);
                            return price;
                        }
                    }
                }
                
                console.log(`Using fallback price for ${symbol}`);
                return 25.00; // Fallback silver price
                
            } catch (error) {
                console.error(`Error fetching commodity price for ${symbol}:`, error);
                return 25.00;
            }
        }

        async function updateExchangeRates() {
            try {
                // Fetch USD/PLN rate from NBP
                const url = 'https://api.nbp.pl/api/exchangerates/rates/a/usd/?format=json';
                const response = await fetch(url);
                
                if (response.ok) {
                    const data = await response.json();
                    const rate = data.rates[0].mid;
                    exchangeRates['USD/PLN'] = rate;
                    console.log(`‚úÖ Updated USD/PLN rate: ${rate}`);
                } else {
                    console.warn('Failed to fetch USD/PLN rate, using fallback');
                }
                
            } catch (error) {
                console.error('Error fetching exchange rates:', error);
            }
        }

        function updateDisplay() {
            // Update overview cards
            document.getElementById('total-value').textContent = `z≈Ç ${portfolio.totalValue.toLocaleString('pl-PL', {minimumFractionDigits: 2})}`;
            
            const unrealizedPLPercent = portfolio.totalCost > 0 ? (portfolio.unrealizedPL / portfolio.totalCost) * 100 : 0;
            document.getElementById('unrealized-pl').textContent = `z≈Ç ${portfolio.unrealizedPL.toLocaleString('pl-PL', {minimumFractionDigits: 2})}`;
            document.getElementById('unrealized-pl').className = portfolio.unrealizedPL >= 0 ? 'text-3xl font-bold text-green-600' : 'text-3xl font-bold text-red-600';
            document.getElementById('unrealized-percent').textContent = `${unrealizedPLPercent.toFixed(2)}%`;
            
            document.getElementById('realized-pl').textContent = `z≈Ç ${portfolio.realizedPL.toLocaleString('pl-PL', {minimumFractionDigits: 2})}`;
            document.getElementById('realized-pl').className = portfolio.realizedPL >= 0 ? 'text-3xl font-bold text-green-600' : 'text-3xl font-bold text-red-600';
            
            document.getElementById('total-dividends').textContent = `z≈Ç ${portfolio.totalDividends.toLocaleString('pl-PL', {minimumFractionDigits: 2})}`;
            
            const dividendYield = portfolio.totalValue > 0 ? (portfolio.totalDividends / portfolio.totalValue) * 100 : 0;
            document.getElementById('dividend-yield').textContent = `Yield: ${dividendYield.toFixed(2)}%`;
            
            // Update holdings table
            updateHoldingsTable();
            
            // Update charts
            updateCharts();
        }

        function updateHoldingsTable() {
            const tbody = document.getElementById('holdings-body');
            tbody.innerHTML = '';
            
            portfolio.holdings.forEach(holding => {
                const costBasis = holding.totalCost / holding.units;
                const unrealizedPL = holding.marketValue - holding.totalCost;
                const unrealizedPercent = holding.totalCost > 0 ? (unrealizedPL / holding.totalCost) * 100 : 0;
                
                const row = document.createElement('tr');
                
                // Show price error if present
                const priceDisplay = holding.priceError ? 
                    `<span class="text-red-600 text-xs">‚ùå ${holding.priceError}</span>` : 
                    `z≈Ç ${holding.currentPrice.toFixed(2)}`;
                    
                const marketValueDisplay = holding.priceError ? 
                    `<span class="text-red-600 text-xs">‚ùå Error</span>` : 
                    `z≈Ç ${holding.marketValue.toFixed(2)}`;
                
                row.innerHTML = `
                    <td class="px-6 py-4 whitespace-nowrap">
                        <div class="text-sm font-medium text-gray-900">${holding.symbol}</div>
                        <div class="text-sm text-gray-500">${holding.market}</div>
                    </td>
                    <td class="px-6 py-4 whitespace-nowrap text-right text-sm">${holding.units.toFixed(6)}</td>
                    <td class="px-6 py-4 whitespace-nowrap text-right text-sm">${priceDisplay}</td>
                    <td class="px-6 py-4 whitespace-nowrap text-right text-sm font-medium">${marketValueDisplay}</td>
                    <td class="px-6 py-4 whitespace-nowrap text-right text-sm">z≈Ç ${holding.totalCost.toFixed(2)}</td>
                    <td class="px-6 py-4 whitespace-nowrap text-right text-sm ${unrealizedPL >= 0 ? 'text-green-600' : 'text-red-600'}">
                        ${holding.priceError ? '‚ùå Error' : `z≈Ç ${unrealizedPL.toFixed(2)}`}
                    </td>
                    <td class="px-6 py-4 whitespace-nowrap text-right text-sm ${unrealizedPercent >= 0 ? 'text-green-600' : 'text-red-600'}">
                        ${holding.priceError ? '‚ùå Error' : `${unrealizedPercent.toFixed(2)}%`}
                    </td>
                `;
                tbody.appendChild(row);
            });
        }

        function updateCharts() {
            updateValueChart();
            updateAllocationChart();
        }

        function updateValueChart() {
            const ctx = document.getElementById('value-chart').getContext('2d');
            
            // Destroy existing chart if it exists
            const existingChart = Chart.getChart(ctx);
            if (existingChart) {
                existingChart.destroy();
            }
            
            // Generate sample daily data for last 30 days
            const data = [];
            const today = new Date();
            let value = portfolio.totalValue * 0.8; // Start 20% lower
            
            for (let i = 30; i >= 0; i--) {
                const date = new Date(today);
                date.setDate(date.getDate() - i);
                
                value *= (1 + (Math.random() - 0.5) * 0.03); // Random daily change
                
                data.push({
                    x: date,
                    y: value
                });
            }
            
            new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: [{
                        label: 'Portfolio Value',
                        data: data,
                        borderColor: '#3B82F6',
                        backgroundColor: 'rgba(59, 130, 246, 0.1)',
                        borderWidth: 2,
                        fill: true
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                displayFormats: {
                                    day: 'MMM dd'
                                }
                            }
                        },
                        y: {
                            beginAtZero: false,
                            ticks: {
                                callback: function(value) {
                                    return 'z≈Ç ' + value.toFixed(0);
                                }
                            }
                        }
                    }
                }
            });
        }

        function updateAllocationChart() {
            const ctx = document.getElementById('allocation-chart').getContext('2d');
            
            // Destroy existing chart if it exists
            const existingChart = Chart.getChart(ctx);
            if (existingChart) {
                existingChart.destroy();
            }
            
            const marketData = new Map();
            portfolio.holdings.forEach(holding => {
                const market = holding.market || 'Unknown';
                marketData.set(market, (marketData.get(market) || 0) + holding.marketValue);
            });
            
            const labels = Array.from(marketData.keys());
            const data = Array.from(marketData.values());
            const colors = ['#3B82F6', '#10B981', '#F59E0B', '#EF4444'];
            
            new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: labels,
                    datasets: [{
                        data: data,
                        backgroundColor: colors.slice(0, labels.length),
                        borderWidth: 2,
                        borderColor: '#ffffff'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'bottom'
                        }
                    }
                }
            });
        }

        function loadSampleData() {
            // Sample portfolio data
            portfolio.holdings.set('AAPL', {
                symbol: 'AAPL',
                market: 'US',
                currency: 'USD',
                units: 10,
                totalCost: 1500,
                dividends: 25,
                realizedPL: 0,
                currentPrice: 175.43,
                marketValue: 1754.30
            });
            
            portfolio.holdings.set('Bitcoin', {
                symbol: 'Bitcoin',
                market: 'CRYPTO',
                currency: 'USD',
                units: 0.1,
                totalCost: 4200,
                dividends: 0,
                realizedPL: 0,
                currentPrice: 67250,
                marketValue: 6725
            });
            
            // Calculate totals
            portfolio.totalValue = 0;
            portfolio.totalCost = 0;
            portfolio.unrealizedPL = 0;
            portfolio.realizedPL = 0;
            portfolio.totalDividends = 0;
            
            portfolio.holdings.forEach(holding => {
                portfolio.totalValue += holding.marketValue;
                portfolio.totalCost += holding.totalCost;
                portfolio.unrealizedPL += holding.marketValue - holding.totalCost;
                portfolio.realizedPL += holding.realizedPL;
                portfolio.totalDividends += holding.dividends;
            });
        }

        // Start the application
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>